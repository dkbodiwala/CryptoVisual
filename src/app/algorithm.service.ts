import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { AES } from 'crypto-ts';
import { Algorithm } from './model/algorithm';
import { Cipher } from 'js-cipher';
import { Output } from './model/output';
import db from '../../db';
import { Router } from '@angular/router';
const railFenceCiper = require('railfencecipher');
const RC4 = require('rc4');

@Injectable({
  providedIn: 'root'
})
export class AlgorithmService {

  baseEndpoint: string = "/"
  constructor(private http: HttpClient, private router: Router) { }

  getAllAlgorithms(): Algorithm[] {
    return db.dataAlgo;
  }

  getAlgorithm(id: number): Algorithm {
    if(db.dataAlgo[id - 1] == undefined) {
      this.router.navigateByUrl(`/algorithm`);
    }
    return db.dataAlgo[id - 1];
  }

  encrypt(id: number, text: string, key: string): Output {
    if (id == 1) {
      return this.encryptCeasar(text, key);
    } else if (id == 2) {
      return this.encryptRailFenceCipher(text, key);
    } else if (id == 3) {
      return this.encryptAES(text, key);
    } else if (id == 4) {
      return this.encryptRC4(text, key);
    } else {
      return {
        text, key, cipherText: ""
      };
    }
  }

  encryptCeasar(text: string, key: string): Output {
    let cipher = new Cipher();
    if (isNaN(text as any)) {
      if (!isNaN(key as any)) {
        let parsedKey = parseInt(key, 10);
        let cipherText = cipher.encrypt(text, parsedKey);

        let alphabets: string[] = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];
        let newAlphabets: string[];
        let alphabetsCopy = [...alphabets];
        newAlphabets = alphabetsCopy.concat(alphabetsCopy.splice(0, parsedKey));

        let steps: string[][] = [];
        steps[0] = text.split('');;
        steps[1] = cipherText.split('');
        steps[2] = alphabets;
        steps[3] = newAlphabets;

        return {
          text, key, cipherText: cipherText, steps
        };
      } else {
        throw new Error("Key cannot be a string, it needs to be a number");
      }
    } else {
      throw new Error("Text cannot contain number, it needs to be a string");
    }
  }

  encryptRailFenceCipher(text: string, key: string): Output {
    if (!isNaN(key as any)) {
      let parsedKey = parseInt(key, 10);
      if (parsedKey > 1) {
        let cipherText = railFenceCiper.encodeRailFenceCipher(text, parsedKey);
        let steps = this.generateRailFenceSteps(text, parsedKey);
        return {
          text, key, cipherText: cipherText, steps
        };
      } else {
        throw new Error("Key must be greater than 1");
      }
    } else {
      throw new Error("Key cannot be a string, it needs to be a number");
    }
  }

  generateRailFenceSteps(text: string, key: number): string[][] {
    let steps: string[][] = [];
    let j: number = 0;
    for (let m = 0; m < key; m++) {
      let emptyArray = []
      for (let n = 0; n < text.length; n++) {
        emptyArray[n] = " ";
      }
      steps[m] = emptyArray;
    }
    let flip = true;
    for (let i = 0; i < text.length; i++) {
      if (j == key - 1 || j == 0) {
        flip = !flip;
      }
      steps[j][i] = text.charAt(i);
      if (flip) {
        j--;
      } else {
        j++;
      }
    }
    return (steps);
  }

  encryptAES(text: string, key: string): Output {
    try {
      const cipherText: string = AES.encrypt(text, key).toString();
      return{ 
        text, key, cipherText: cipherText 
      };
    } catch (error) {
      throw error;
    }
  }

  //https://stackoverflow.com/questions/30651062/how-to-use-the-xor-on-two-strings
  encryptRC4(text: string, key: string): Output {
    try {
      let generator = new RC4(key);
      let steps:any[] = [];
      steps[0] = ["Plain Text"];
      steps[1] = ["Plain Text (in Hexadecimal)"];
      steps[2] = ["Random Keystream Generated by RC4 (in Hexadecimal)"];
      steps[3] = ["Cipher Text (in Hexadecimal)"];
      let cipherText = "";
      for (let i = 0; i < text.length; i++) {
        let randbomByte = generator.randomByte();
        let xor = (text.charAt(i).charCodeAt(0) ^ randbomByte).toString(16);
        cipherText = cipherText + xor;
        steps[0].push(text.charAt(i))
        steps[1].push(text.charAt(i).charCodeAt(0).toString(16))
        steps[2].push(randbomByte.toString(16));
        steps[3].push(xor);
      }
      return {
        text, key, cipherText, steps 
      };
    } catch (error) {
      throw error;
    }
  }
}
